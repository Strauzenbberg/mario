<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Plataforma 2D Simplificada</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #5c94fc; }
    #score {
      position: absolute; top: 10px; left: 10px;
      font-family: sans-serif; font-size: 20px; color: #fff;
      text-shadow: 1px 1px 2px #000; z-index: 10;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

    // 1. Cena, câmera e renderer
    const scene    = new THREE.Scene();
    const aspect   = window.innerWidth / window.innerHeight;
    const viewSize = 600;
    const cam = new THREE.OrthographicCamera(
      -aspect*viewSize/2, aspect*viewSize/2,
       viewSize/2, -viewSize/2,
       0.1, 1000
    );
    cam.position.z = 10;
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      const a = window.innerWidth / window.innerHeight;
      cam.left   = -a*viewSize/2; cam.right  = a*viewSize/2;
      cam.top    =  viewSize/2;   cam.bottom = -viewSize/2;
      cam.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 2. Áudio simples
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playTone(freq, dur=0.1) {
      const osc  = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.type = 'square'; osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      osc.start(); osc.stop(audioCtx.currentTime + dur);
    }
    const SFX = { jump:440, coin:880, hit:220 };

    // 3. Input
    const keys = {};
    window.addEventListener('keydown', e => keys[e.code]=true);
    window.addEventListener('keyup',   e => keys[e.code]=false);

    // 4. Entidades geométricas
    function createBox(w,h,color){
      const mat = new THREE.MeshBasicMaterial({ color });
      const geo = new THREE.BoxGeometry(w,h,1);
      return new THREE.Mesh(geo, mat);
    }
    function createSphere(r,color){
      const mat = new THREE.MeshBasicMaterial({ color });
      const geo = new THREE.SphereGeometry(r,12,12);
      return new THREE.Mesh(geo, mat);
    }

    // Jogador
    const player = createBox(40,60, 0xff0000);
    player.position.set(0,-200,0);
    scene.add(player);
    let vel = new THREE.Vector2(0,0), jumping = false;

    // Plataformas
    const platforms = [];
    function addPlat(x,y,w,h){
      const p = createBox(w,h,0x228822);
      p.position.set(x + w/2, y - h/2, 0);
      scene.add(p); platforms.push(p);
    }
    addPlat(-400, -viewSize/2 +30, 800,60);
    addPlat(-100, -50,120,20);
    addPlat(150,50,150,20);
    addPlat(300,0,100,20);

    // Inimigos
    const enemies = [];
    function addEnemy(x,y,range){
      const e = createBox(40,60,0x0000ff);
      e.position.set(x,y,0);
      e.userData = { range, dir:1 };
      scene.add(e); enemies.push(e);
    }
    addEnemy(-100,-100,[-150,150]);
    addEnemy(200,0,[180,300]);

    // Moedas
    const coins = [];
    function addCoin(x,y){
      const c = createSphere(15,0xffff00);
      c.position.set(x,y,0);
      scene.add(c); coins.push(c);
    }
    addCoin(-50,0); addCoin(100,50); addCoin(250,20);

    // Física básica e loop
    let last = performance.now(), score = 0;
    function loop(){
      const now = performance.now(), dt = (now-last)/1000;
      last = now;

      // Movimento do jogador
      if (keys['ArrowLeft'])  vel.x = -150;
      else if (keys['ArrowRight']) vel.x = 150;
      else vel.x = 0;

      if (keys['Space'] && !jumping){
        vel.y = 350; jumping=true;
        playTone(SFX.jump);
      }

      vel.y -= 600 * dt; // gravidade
      player.position.x += vel.x * dt;
      player.position.y += vel.y * dt;

      // Colisão chão simples
      if (player.position.y < -viewSize/2+30){
        player.position.y = -viewSize/2+30;
        vel.y = 0; jumping=false;
      }

      // Colisão com plataformas
      platforms.forEach(p=>{
        const dx = Math.abs(player.position.x - p.position.x);
        const dy = player.position.y - (p.position.y + p.geometry.parameters.height/2);
        if (dx < 20 + p.geometry.parameters.width/2 &&
            dy < 0 && dy > -5 && vel.y < 0){
          player.position.y = p.position.y + p.geometry.parameters.height/2 + 30;
          vel.y = 0; jumping=false;
        }
      });

      // Inimigos
      enemies.forEach(e=>{
        e.position.x += e.userData.dir * 80 * dt;
        const [minX,maxX] = e.userData.range;
        if (e.position.x < minX || e.position.x > maxX){
          e.userData.dir *= -1;
        }
        // colisão simples
        if (player.position.distanceTo(e.position) < 40){
          playTone(SFX.hit,0.2);
          player.position.set(0,-200,0);
          vel.set(0,0); jumping = false;
        }
      });

      // Moedas
      coins.forEach((c,i)=>{
        if (player.position.distanceTo(c.position) < 30){
          playTone(SFX.coin,0.1);
          scene.remove(c); coins.splice(i,1);
          score += 10;
          document.getElementById('score').innerText = 'Score: '+score;
        }
      });

      // Câmera segue
      cam.position.x = player.position.x;
      cam.position.y = player.position.y;
      cam.updateProjectionMatrix();

      renderer.render(scene, cam);
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
