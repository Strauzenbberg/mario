<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Plataforma 2D Estilo Mario – Single File</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #5c94fc; }
    #score {
      position: absolute; top: 10px; left: 10px;
      font-family: sans-serif; font-size: 20px; color: #fff;
      text-shadow: 1px 1px 2px #000; z-index: 10;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

    // ——————————————————————————————————————————————————————————————
    // 1. SETUP BÁSICO: cena, câmera ortográfica e renderer WebGL
    const scene    = new THREE.Scene();
    const aspect   = window.innerWidth / window.innerHeight;
    const viewSize = 600;
    const camera   = new THREE.OrthographicCamera(
      -aspect * viewSize / 2, aspect * viewSize / 2,
       viewSize / 2, -viewSize / 2,
       0.1, 1000
    );
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      const a = window.innerWidth / window.innerHeight;
      camera.left   = -a * viewSize / 2;
      camera.right  =  a * viewSize / 2;
      camera.top    =  viewSize / 2;
      camera.bottom = -viewSize / 2;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ——————————————————————————————————————————————————————————————
    // 2. ÁUDIO: Web Audio API (“sons do Chrome”)
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playTone(freq, duration = 0.1, type = 'square') {
      const osc  = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      osc.type            = type;
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    const sounds = {
      jump: { freq: 440, dur: 0.12 },
      coin: { freq: 880, dur: 0.08 },
      hit:  { freq: 220, dur: 0.2  }
    };
    function play(name) {
      const s = sounds[name];
      if (s) playTone(s.freq, s.dur);
    }

    // ——————————————————————————————————————————————————————————————
    // 3. INPUT
    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup',   e => keys[e.code] = false);

    // ——————————————————————————————————————————————————————————————
    // 4. CLASSE BASE PARA SPRITES ANIMADOS
    class SpriteEntity {
      constructor({ src, framesX, framesY, width, height, speed }) {
        this.framesX = framesX;
        this.framesY = framesY;
        this.total   = framesX * framesY;
        this.current = 0;
        this.speed   = speed || 8;
        this.acc     = 0;

        const tex = new THREE.TextureLoader().load(src);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(1/framesX, 1/framesY);

        this.mat    = new THREE.SpriteMaterial({ map: tex, transparent: true });
        this.sprite = new THREE.Sprite(this.mat);
        this.sprite.scale.set(width, height, 1);
        scene.add(this.sprite);
      }

      updateAnim(delta) {
        this.acc += delta;
        const interval = 1 / this.speed;
        if (this.acc >= interval) {
          this.current = (this.current + 1) % this.total;
          const col = this.current % this.framesX;
          const row = Math.floor(this.current / this.framesX);
          this.mat.map.offset.set(
            col / this.framesX,
            1 - (row + 1) / this.framesY
          );
          this.acc -= interval;
        }
      }
    }

    // ——————————————————————————————————————————————————————————————
    // 5. PLAYER
    class Player extends SpriteEntity {
      constructor() {
        super({
          src:    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABGUlEQVR4nO3QMQEAAAwDINc/9F2gDhQF1phcCgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQI1FT3awAAABJRU5ErkJggg==',
          framesX:4, framesY:4, width: 40, height: 60, speed: 10
        });
        this.pos       = new THREE.Vector3(0, -200, 0);
        this.vel       = new THREE.Vector3(0, 0, 0);
        this.speed     = 150;
        this.gravity   = -600;
        this.jumpForce = 350;
        this.jumping   = false;
      }

      update(delta) {
        // movimento horizontal
        if (keys['ArrowLeft'])  this.vel.x = -this.speed;
        else if (keys['ArrowRight']) this.vel.x =  this.speed;
        else this.vel.x = 0;

        // pulo
        if (keys['Space'] && !this.jumping) {
          this.vel.y = this.jumpForce;
          this.jumping = true;
          play('jump');
        }

        // gravidade
        this.vel.y += this.gravity * delta;
        this.pos.addScaledVector(this.vel, delta);

        // piso
        if (this.pos.y < -viewSize/2 + 30) {
          this.pos.y = -viewSize/2 + 30;
          this.vel.y = 0;
          this.jumping = false;
        }

        this.sprite.position.copy(this.pos);
        this.updateAnim(delta);
      }
    }

    // ——————————————————————————————————————————————————————————————
    // 6. INIMIGO
    class Enemy extends SpriteEntity {
      constructor(x, y, range) {
        super({
          src:    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAABGUlEQVR4nO3QMQEAAAwDINc/9F2gDhQF1phcCgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQIFAgUCBQI1FT3awAAABJRU5ErkJggg==',
          framesX:4, framesY:4, width: 40, height: 60, speed: 6
        });
        this.pos       = new THREE.Vector3(x, y, 0);
        this.range     = range;
        this.speed     = 80;
        this.direction = 1;
      }

      update(delta) {
        this.pos.x += this.direction * this.speed * delta;
        if (this.pos.x > this.range[1] || this.pos.x < this.range[0]) {
          this.direction *= -1;
          this.sprite.scale.x *= -1;
        }
        this.sprite.position.copy(this.pos);
        this.updateAnim(delta);
      }
    }

    // ——————————————————————————————————————————————————————————————
    // 7. MOEDA
    class Coin extends SpriteEntity {
      constructor(x, y) {
        super({
          src:    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAP0lEQVR4nO3MMQEAAAgCIP+9F2gHIhoe6mYGAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAPkQAQAAAAASUVORK5CYII=',
          framesX:1, framesY:4, width: 30, height: 30, speed: 8
        });
        this.pos = new THREE.Vector3(x, y, 0);
        this.sprite.position.copy(this.pos);
      }

      update(delta) {
        this.updateAnim(delta);
      }
    }

    // ——————————————————————————————————————————————————————————————
    // 8. PLATAFORMAS
    const platforms = [];
    function createPlatform(x, y, w, h) {
      const geo = new THREE.BoxGeometry(w, h, 10);
      const mat = new THREE.MeshBasicMaterial({ color: 0x228822 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x + w/2, y - h/2, -5);
      scene.add(mesh);
      platforms.push(mesh);
    }

    // ——————————————————————————————————————————————————————————————
    // 9. INSTÂNCIAS
    const player = new Player();
    const enemies = [
      new Enemy(-100, -100, [-150, 150]),
      new Enemy(200,    0,   [180, 300])
    ];
    const coins = [
      new Coin(-50,  0),
      new Coin(100,  50),
      new Coin(250,  20)
    ];

    createPlatform(-400, -viewSize/2 + 30, 800, 60);
    createPlatform(-100, -50,              120, 20);
    createPlatform(150,   50,              150, 20);
    createPlatform(300,    0,              100, 20);

    let lastTime = performance.now();
    let score    = 0;

    // colisão AABB simplificada
    function boxCollider(aPos, aSize, mesh) {
      const mx = mesh.position.x - mesh.geometry.parameters.width/2;
      const my = mesh.position.y + mesh.geometry.parameters.height/2;
      return (
        aPos.x + aSize.x/2  > mx &&
        aPos.x - aSize.x/2  < mx + mesh.geometry.parameters.width &&
        aPos.y - aSize.y/2  < my &&
        aPos.y + aSize.y/2  > my - mesh.geometry.parameters.height
      );
    }

    // ——————————————————————————————————————————————————————————————
    // 10. LOOP PRINCIPAL
    function loop() {
      const now   = performance.now();
      const delta = (now - lastTime) / 1000;
      lastTime    = now;

      player.update(delta);

      // colisão com plataformas
      platforms.forEach(p => {
        if (boxCollider(player.pos, new THREE.Vector2(40,60), p)
            && player.vel.y <= 0) {
          player.pos.y = p.position.y + p.geometry.parameters.height/2 + 60/2;
          player.vel.y = 0;
          player.jumping = false;
        }
      });

      // inimigos
      enemies.forEach(e => {
        e.update(delta);
        if (player.pos.distanceTo(e.pos) < 40) {
          play('hit');
          player.pos.set(0, -200, 0);
          player.vel.set(0, 0, 0);
        }
      });

      // moedas
      coins.forEach((c, i) => {
        c.update(delta);
        if (player.pos.distanceTo(c.pos) < 30) {
          play('coin');
          scene.remove(c.sprite);
          coins.splice(i, 1);
          score += 10;
          document.getElementById('score').innerText = 'Score: ' + score;
        }
      });

      // câmera segue
      camera.position.x = player.pos.x;
      camera.position.y = player.pos.y;
      camera.updateProjectionMatrix();

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
